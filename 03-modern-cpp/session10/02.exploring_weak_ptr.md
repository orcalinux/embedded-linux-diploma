# Exploring `std::weak_ptr` in C++

- ✓ Problem
- ✓ Solution
- ✓ Deep Usage Examples

---

## 1. The Problem: Reference‑Count Cycles

When two objects hold `std::shared_ptr` to each other, neither’s reference count ever drops to zero—even when all external owners go out of scope. This leaks memory permanently.

```cpp
// File: cyclic_leak.cpp
#include <memory>
#include <iostream>

struct Node {
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> prev;   // ← strong cycle!
    ~Node() { std::cout << "Node destroyed\n"; }
};

int main() {
    {
        auto a = std::make_shared<Node>();
        auto b = std::make_shared<Node>();
        a->next = b;
        b->prev = a;
        std::cout << "Inside scope: a.use_count=" << a.use_count()
                  << ", b.use_count=" << b.use_count() << "\n";
    }
    // Neither destructor runs here!
    std::cout << "Exited scope; memory leaked due to cycle.\n";
    return 0;
}
```

**Test**

```bash
g++ -std=c++17 cyclic_leak.cpp -o cyclic_leak && ./cyclic_leak
```

You’ll see the use_counts but never see “Node destroyed.”

---

## 2. The Solution: Break the Cycle with `std::weak_ptr`

Swap one of the strong links for a non‑owning `weak_ptr`. It observes without incrementing the reference count.

```cpp
// File: cycle_broken.cpp
#include <memory>
#include <iostream>

struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node>   prev;  // ← breaks the cycle
    ~Node() { std::cout << "Node destroyed\n"; }
};

int main() {
    {
        auto a = std::make_shared<Node>();
        auto b = std::make_shared<Node>();
        a->next = b;
        b->prev = a;  // now a weak link

        std::cout << "Inside scope: a.use_count=" << a.use_count()
                  << ", b.use_count=" << b.use_count() << "\n";
    }
    // Both Node destructors run:
    std::cout << "Exited scope; no leaks.\n";
    return 0;
}
```

**Test**

```bash
g++ -std=c++17 cycle_broken.cpp -o cycle_broken && ./cycle_broken
```

---

## 3. Core Concepts of `std::weak_ptr`

1. **No Ownership:** Doesn’t increment the shared count.
2. **Control Block:** Shares the same block as `shared_ptr`, tracking strong & weak counts.
3. **Expired vs. Locked:**

   - `.expired()` → `true` once all `shared_ptr`s gone.
   - `.lock()` → returns a `shared_ptr` if still alive, otherwise empty.

---

## 4. Deeper Usage Examples

### 4.1 Basic Observation & Safety Check

```cpp
#include <memory>
#include <iostream>

int main() {
    auto owner = std::make_shared<int>(2025);
    std::weak_ptr<int> observer = owner;

    if (auto p = observer.lock()) {
        std::cout << "Value is: " << *p << " (still alive)\n";
    }
    owner.reset();  // destroy the last shared owner

    std::cout << (observer.expired()
        ? "Observer: resource expired\n"
        : "Observer: resource still alive\n");
}
```

### 4.2 Cache / Flyweight Pattern

Maintain a cache without extending lifetimes inadvertently:

```cpp
#include <memory>
#include <iostream>
#include <unordered_map>

std::unordered_map<std::string,std::weak_ptr<std::string>> flyweights;

std::shared_ptr<std::string> getFlyweight(const std::string& key) {
    if (auto w = flyweights[key].lock()) {
        std::cout << "[Cache] Reusing \"" << *w << "\"\n";
        return w;
    }
    auto s = std::make_shared<std::string>(key);
    flyweights[key] = s;
    std::cout << "[Cache] Creating \"" << *s << "\"\n";
    return s;
}

int main() {
    auto s1 = getFlyweight("hello");
    auto s2 = getFlyweight("hello");  // hit
    return 0;
}
```

### 4.3 Observer in Event Callbacks

Let callbacks hold `weak_ptr` to avoid prolonging object lifetimes:

```cpp
#include <memory>
#include <iostream>
#include <functional>
#include <vector>

struct Button {
    std::vector<std::function<void()>> listeners;
    void click() {
        for (auto& fn : listeners) fn();
    }
};

int main() {
    auto btn = std::make_shared<Button>();
    std::weak_ptr<Button> wp = btn;

    // register a listener
    btn->listeners.push_back([wp]() {
        if (auto p = wp.lock()) {
            std::cout << "Button clicked!\n";
        } else {
            std::cout << "Listener: Button gone\n";
        }
    });

    btn->click();        // prints "Button clicked!"
    btn.reset();         // destroy the button
    btn->click();        // would crash, but p.expired() prevents it
    return 0;
}
```

### 4.4 Transient Background Monitor

A background thread polls a resource without owning it:

```cpp
#include <memory>
#include <iostream>
#include <thread>
#include <chrono>

void monitor(std::weak_ptr<int> wp) {
    while (true) {
        std::this_thread::sleep_for(std::chrono::milliseconds(300));
        if (auto p = wp.lock()) {
            std::cout << "[Monitor] Value = " << *p << "\n";
        } else {
            std::cout << "[Monitor] Resource expired, stopping\n";
            break;
        }
    }
}

int main() {
    auto data = std::make_shared<int>(7);
    std::thread t(monitor, data);
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    data.reset();  // release the data
    t.join();
    return 0;
}
```

---

## 5. Summary

- **Use `weak_ptr`** to observe without owning.
- **Never dereference directly**—always `.lock()` first.
- **Great for** breaking cycles, caches, callbacks, monitoring.
