# Smart Pointers in Modern C++

**A detailed, exampleâ€‘driven walkthrough of C++ smart pointers: `std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`, plus the deprecated `std::auto_ptr`.**

---

## Table of Contents

- [Smart Pointers in Modern C++](#smart-pointers-in-modern-c)
  - [Table of Contents](#table-of-contents)
  - [Introduction](#introduction)
  - [Why Use Smart Pointers?](#why-use-smart-pointers)
    - [Illustrative Examples of Manual Management Pitfalls ](#illustrative-examples-of-manual-management-pitfalls-)
      - [Example 1: Memory Leak](#example-1-memory-leak)
      - [Example 2: Dangling Pointer](#example-2-dangling-pointer)
      - [Example 3: Exception Safety Issue](#example-3-exception-safety-issue)
  - [Overview of Smart Pointer Types](#overview-of-smart-pointer-types)
  - [Deep Dive: `std::unique_ptr` ](#deep-dive-stdunique_ptr-)
    - [Ownership and Lifetime ](#ownership-and-lifetime-)
    - [Null State and Checks ](#null-state-and-checks-)
    - [Performance Characteristics ](#performance-characteristics-)
    - [Custom Deleters and Use Cases ](#custom-deleters-and-use-cases-)
    - [Examples ](#examples-)
      - [Example 1: Basic `new`](#example-1-basic-new)
      - [Example 2: `std::make_unique`](#example-2-stdmake_unique)
      - [Example 3: Array Management](#example-3-array-management)
      - [Example 4: Custom Deleter](#example-4-custom-deleter)
      - [Example 5: Move Semantics](#example-5-move-semantics)
  - [Deep Dive: `std::shared_ptr` ](#deep-dive-stdshared_ptr-)
    - [Reference Counting Mechanism ](#reference-counting-mechanism-)
    - [Thread Safety Guarantees ](#thread-safety-guarantees-)
    - [Aliasing and Aliasing Constructor ](#aliasing-and-aliasing-constructor-)
    - [Custom Deleters and Overhead ](#custom-deleters-and-overhead-)
    - [Examples ](#examples--1)
      - [Example 1: Basic `new`](#example-1-basic-new-1)
      - [Example 2: `std::make_shared`](#example-2-stdmake_shared)
      - [Example 3: Aliasing Constructor](#example-3-aliasing-constructor)
      - [Example 4: Custom Deleter](#example-4-custom-deleter-1)
      - [Example 5: `enable_shared_from_this`](#example-5-enable_shared_from_this)
  - [Deep Dive: `std::weak_ptr` ](#deep-dive-stdweak_ptr-)
    - [When and Why to Use `std::weak_ptr` ](#when-and-why-to-use-stdweak_ptr-)
    - [Observer Role and Non-Ownership ](#observer-role-and-non-ownership-)
    - [Locking vs. Expired State ](#locking-vs-expired-state-)
    - [Breaking Cyclic Dependencies ](#breaking-cyclic-dependencies-)
    - [Examples ](#examples--2)
      - [Example 1: Basic Lock](#example-1-basic-lock)
      - [Example 2: Expiration Check](#example-2-expiration-check)
      - [Example 3: Breaking Cycles](#example-3-breaking-cycles)
      - [Example 4: Cache Observer](#example-4-cache-observer)
  - [Deprecated: `std::auto_ptr` ](#deprecated-stdauto_ptr-)
    - [Copy-Transfer Semantics ](#copy-transfer-semantics-)
    - [Common Pitfalls ](#common-pitfalls-)
    - [Examples ](#examples--3)
      - [Example 1: Return from Function](#example-1-return-from-function)
      - [Example 2: Copy Assignment](#example-2-copy-assignment)
      - [Example 3: Function Parameter](#example-3-function-parameter)
      - [Example 4: Container Pitfalls](#example-4-container-pitfalls)
  - [Method Reference](#method-reference)
    - [`std::unique_ptr` Methods](#stdunique_ptr-methods)
    - [`std::shared_ptr` Methods](#stdshared_ptr-methods)
    - [`std::weak_ptr` Methods](#stdweak_ptr-methods)
    - [`std::auto_ptr` Methods (Deprecated)](#stdauto_ptr-methods-deprecated)

---

## Introduction

Memory management in C++ has evolved significantly since manual `new`/`delete` usage. **Smart pointers** implement RAII (Resource Acquisition Is Initialization) by binding dynamic resource lifetimes to object lifetimes, reducing leaks and crashes. This guide offers an in-depth look at each modern smart pointer, explaining their internals, performance, and best uses before diving into examples.

---

## Why Use Smart Pointers?

Manual memory management often leads to:

- **Memory leaks:** forgetting `delete`.
- **Dangling pointers:** deleting prematurely.
- **Exception unsafety:** missing cleanup during stack unwinding.

### Illustrative Examples of Manual Management Pitfalls <a id="manual-examples"></a>

#### Example 1: Memory Leak

```cpp
#include <iostream>

int main() {
    int* p = new int(42);
    std::cout << "Value: " << *p << std::endl;
    // forgot delete(); memory leak occurs
    return 0;
}
```

#### Example 2: Dangling Pointer

```cpp
#include <iostream>

int* getDangling() {
    int local = 100;
    return &local; // returns address of destroyed stack memory
}

int main() {
    int* p = getDangling();
    std::cout << "Dangling value: " << *p << std::endl; // undefined behavior
    return 0;
}
```

#### Example 3: Exception Safety Issue

```cpp
#include <iostream>
#include <stdexcept>

int main() {
    int* arr = new int[5];
    throw std::runtime_error("Oops!"); // no delete -> leak
    delete[] arr;
    return 0;
}
```

---

## Overview of Smart Pointer Types

| Type              | Ownership Model            | Copyable? | Key Features                              |
| ----------------- | -------------------------- | --------- | ----------------------------------------- |
| `std::unique_ptr` | Exclusive (single owner)   | No        | Zero overhead; owns one resource; movable |
| `std::shared_ptr` | Shared (reference count)   | Yes       | Controlled sharing; thread-safe refs      |
| `std::weak_ptr`   | Observer (no ownership)    | Yes       | Breaks cycles; checks validity            |
| `std::auto_ptr`   | Exclusive (copy transfers) | Yes       | Deprecated; unsafe copy semantics         |

---

## Deep Dive: `std::unique_ptr` <a id="deep-dive-stduniqueptr"></a>

### Ownership and Lifetime <a id="ownership-and-lifetime"></a>

- Holds sole ownership of a dynamically allocated object.
- Deletes owned object in its destructor.
- Non-copyable: copy constructor/assignments are deleted to prevent multiple owners.
- Movable: ownership transfers via `std::move` without overhead.

### Null State and Checks <a id="null-state-and-checks"></a>

- Can represent an empty state by storing `nullptr`.
- Use `if (ptr)` or `ptr != nullptr` to check validity.
- Safe to dereference only if non-null.

### Performance Characteristics <a id="performance-characteristics"></a>

- Typically same size as a raw pointer.
- No reference counting overhead.
- Ideal for tight loops or performance-critical code needing exclusive handles.

### Custom Deleters and Use Cases <a id="custom-deleters-and-use-cases"></a>

- Allows custom cleanup logic (lambda, function object).
- Common for file handles, sockets, and other OS resources.
- Deleter type becomes part of `unique_ptr` type, so keep it lightweight where possible.

### Examples <a id="unique-examples"></a>

#### Example 1: Basic `new`

```cpp
#include <memory>
#include <iostream>

int main() {
    auto p1 = std::unique_ptr<int>(new int(42));
    std::cout << "unique_ptr new: " << *p1 << std::endl;
    return 0;
}
```

#### Example 2: `std::make_unique`

```cpp
#include <memory>
#include <iostream>

int main() {
    auto p2 = std::make_unique<std::string>("Hello");
    std::cout << "make_unique: " << *p2 << std::endl;
    return 0;
}
```

#### Example 3: Array Management

```cpp
#include <memory>
#include <iostream>

int main() {
    auto arr = std::make_unique<int[]>(5);
    for(int i = 0; i < 5; ++i) arr[i] = i * i;
    std::cout << "Array values: ";
    for(int i = 0; i < 5; ++i) std::cout << arr[i] << ' ';
    std::cout << std::endl;
    return 0;
}
```

#### Example 4: Custom Deleter

```cpp
#include <memory>
#include <iostream>
#include <cstdio>

int main() {
    auto deleter = [](FILE* f){
        if(f) {
            std::cout << "Closing file via custom deleter" << std::endl;
            fclose(f);
        }
    };
    std::unique_ptr<FILE, decltype(deleter)> file(
        std::fopen("log.txt","w"), deleter
    );
    if (file) {
        std::cout << "File opened successfully" << std::endl;
        std::fprintf(file.get(), "Entry
");
    }
    return 0;
}
```

#### Example 5: Move Semantics

```cpp
#include <memory>
#include <iostream>

int main() {
    auto p3 = std::make_unique<int>(10);
    std::cout << "Before move, p3: " << *p3 << std::endl;
    auto p4 = std::move(p3);
    if(!p3) std::cout << "p3 is now null after move" << std::endl;
    std::cout << "p4 value: " << *p4 << std::endl;
    return 0;
}
```

---

## Deep Dive: `std::shared_ptr` <a id="deep-dive-stdsharedptr"></a>

### Reference Counting Mechanism <a id="reference-counting-mechanism"></a>

- Internally stores counts in a control block:

  - **strong_count**: number of `shared_ptr` owners.
  - **weak_count**: number of `weak_ptr` observers.

- When `strong_count` drops to zero, object is destroyed; control block lives until `weak_count` is zero.

### Thread Safety Guarantees <a id="thread-safety-guarantees"></a>

- Atomic operations for increment/decrement of counts.
- Safe to share `shared_ptr` instances across threads without external locks.

### Aliasing and Aliasing Constructor <a id="aliasing-and-aliasing-constructor"></a>

- `shared_ptr<T> alias(orig, pointer_to_member);`
- Shares ownership of `orig` but points to a sub-object.
- Useful for slicing or container element access.

### Custom Deleters and Overhead <a id="custom-deleters-and-overhead"></a>

- Custom deleter stored alongside control block.
- Extra heap allocation for control block increases memory footprint.

### Examples <a id="shared-examples"></a>

#### Example 1: Basic `new`

```cpp
#include <memory>
#include <iostream>

int main() {
    auto sp1 = std::shared_ptr<int>(new int(100));
    std::cout << "shared_ptr new count: " << sp1.use_count() << std::endl;
    return 0;
}
```

#### Example 2: `std::make_shared`

```cpp
#include <memory>
#include <iostream>
#include <vector>

int main() {
    auto sp2 = std::make_shared<std::vector<int>>(3, 7);
    std::cout << "make_shared size: " << sp2->size() << std::endl;
    return 0;
}
```

#### Example 3: Aliasing Constructor

```cpp
#include <memory>
#include <iostream>
#include <vector>

int main() {
    auto vec = std::make_shared<std::vector<int>>(10, 1);
    std::shared_ptr<int> ele(vec, &(*vec)[5]);
    std::cout << "Aliased element value: " << *ele << std::endl;
    std::cout << "Original use_count: " << vec.use_count() << std::endl;
    return 0;
}
```

#### Example 4: Custom Deleter

```cpp
#include <memory>
#include <iostream>

struct Obj { ~Obj(){ std::cout << "Obj deleted" << std::endl; } };

int main() {
    auto sp3 = std::shared_ptr<Obj>(new Obj,
        [](Obj* p){ std::cout << "Custom deleting Obj" << std::endl; delete p; }
    );
    std::cout << "Custom deleter installed" << std::endl;
    return 0;
}
```

#### Example 5: `enable_shared_from_this`

```cpp
#include <memory>
#include <iostream>

struct Self : std::enable_shared_from_this<Self> {
    void show() {
        std::cout << "use_count inside: "
                  << shared_from_this().use_count() << std::endl;
    }
};

int main() {
    auto sp4 = std::make_shared<Self>();
    std::cout << "use_count before show: " << sp4.use_count() << std::endl;
    sp4->show();
    return 0;
}
```

---

## Deep Dive: `std::weak_ptr` <a id="deep-dive-stdweakptr"></a>

`std::weak_ptr` is an **observer** smart pointer that holds a non-owning reference to an object managed by `std::shared_ptr`. It does **not** contribute to the reference count, preventing ownership cycles and allowing safe access when ownership is uncertain.

### When and Why to Use `std::weak_ptr` <a id="weak-when-why"></a>

- **Breaking cycles**: In bidirectional or graph-like data structures, using `std::weak_ptr` for one direction avoids memory leaks caused by cyclic `std::shared_ptr` references.
- **Cache or registry patterns**: You can keep objects in a cache or registry without forcing them to stay alive indefinitely; expired objects can be detected and cleaned up.
- **Temporary access**: When you need occasional, non-owning access to a shared resource without extending its lifetime.

**Benefits**:

- **No ownership overhead**: Does not increment the reference count.
- **Cycle safety**: Eliminates reference cycles that would otherwise leak.
- **Validity checks**: `.expired()` and `.lock()` let you safely test for object existence.

### Observer Role and Non-Ownership <a id="observer-role-and-non-ownership"></a>

- Does not contribute to strong reference count.
- Merely observes object managed by `shared_ptr`.
  and Non-Ownership <a id="observer-role-and-non-ownership"></a>
- Does not contribute to strong reference count.
- Merely observes object managed by `shared_ptr`.

### Locking vs. Expired State <a id="locking-vs-expired-state"></a>

- `.lock()` returns a `shared_ptr`; empty if expired.
- `.expired()` returns `true` if no owners remain.

### Breaking Cyclic Dependencies <a id="breaking-cyclic-dependencies"></a>

- Replace one side of bidirectional `shared_ptr` links with `weak_ptr` to avoid leaks.

### Examples <a id="weak-examples"></a>

#### Example 1: Basic Lock

```cpp
#include <memory>
#include <iostream>

int main() {
    auto sp = std::make_shared<int>(5);
    std::weak_ptr<int> wp = sp;
    if(auto p = wp.lock()) {
        std::cout << "Instance alive with value: " << *p << std::endl;
    } else {
        std::cout << "Instance expired" << std::endl;
    }
    return 0;
}
```

#### Example 2: Expiration Check

```cpp
#include <memory>
#include <iostream>

int main() {
    auto sp = std::make_shared<int>(8);
    std::weak_ptr<int> wp = sp;
    sp.reset();
    if(wp.expired()) {
        std::cout << "Pointer expired correctly" << std::endl;
    } else {
        std::cout << "Pointer still valid" << std::endl;
    }
    return 0;
}
```

#### Example 3: Breaking Cycles

```cpp
#include <memory>
#include <iostream>

struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;
};

int main() {
    auto n1 = std::make_shared<Node>();
    auto n2 = std::make_shared<Node>();
    n1->next = n2;
    n2->prev = n1;
    if(auto prev = n2->prev.lock()) {
        std::cout << "Cycle broken: prev exists" << std::endl;
    } else {
        std::cout << "Prev expired" << std::endl;
    }
    return 0;
}
```

#### Example 4: Cache Observer

```cpp
#include <memory>
#include <iostream>
#include <unordered_map>

std::unordered_map<int,std::weak_ptr<int>> cache;

std::shared_ptr<int> get(int key) {
    if(auto w = cache[key].lock()) {
        std::cout << "Cache hit for key " << key << std::endl;
        return w;
    }
    auto s = std::make_shared<int>(key);
    cache[key] = s;
    std::cout << "Cache miss for key " << key << ", creating new value" << std::endl;
    return s;
}

int main() {
    auto v1 = get(42);
    auto v2 = get(42);
    return 0;
}
```

---

## Deprecated: `std::auto_ptr` <a id="deprecated-stdautoptr"></a>

### Copy-Transfer Semantics <a id="copy-transfer-semantics"></a>

- Copy constructor and assignment transfer ownership, leaving source null.

### Common Pitfalls <a id="common-pitfalls"></a>

- Unexpected nulling when passed to functions or stored in containers.
- Removed in C++17 due to unsafe semantics.

### Examples <a id="auto-examples"></a>

#### Example 1: Return from Function

```cpp
#include <memory>
#include <iostream>

std::auto_ptr<int> make() {
    return std::auto_ptr<int>(new int(1));
}

int main() {
    auto p = make();
    std::cout << "auto_ptr from function: " << *p << std::endl;
    return 0;
}
```

#### Example 2: Copy Assignment

```cpp
#include <memory>
#include <iostream>

int main() {
    std::auto_ptr<int> p1(new int(2));
    std::auto_ptr<int> p2 = p1; // p1 becomes null
    if(!p1) std::cout << "p1 is null after copy" << std::endl;
    std::cout << "p2 value: " << *p2 << std::endl;
    return 0;
}
```

#### Example 3: Function Parameter

```cpp
#include <memory>
#include <iostream>

void f(std::auto_ptr<int> p) {
    std::cout << "Inside f, value: " << *p << std::endl;
}

int main() {
    std::auto_ptr<int> p(new int(3));
    f(p); // p becomes null
    if(!p) std::cout << "p is null after passing to function" << std::endl;
    return 0;
}
```

#### Example 4: Container Pitfalls

```cpp
#include <vector>
#include <memory>
#include <iostream>

int main() {
    std::vector<std::auto_ptr<int>> v;
    v.push_back(std::auto_ptr<int>(new int(4)));
    v.push_back(std::auto_ptr<int>(new int(5)));
    for(size_t i = 0; i < v.size(); ++i) {
        std::cout << "Container element " << i << ": " << *v[i] << std::endl;
    }
    return 0;
}
```

## Method Reference

### `std::unique_ptr` Methods

- **`get()`**: returns raw pointer without releasing ownership.
- **`release()`**: releases ownership and returns raw pointer; smart pointer becomes null.
- **`reset(ptr)`**: deletes current object and takes ownership of `ptr` (or null if omitted).
- **`swap(other)`**: swaps ownership with another `unique_ptr`.
- **`operator*()` / `operator->()`**: dereference operators.
- **`operator bool()`**: checks non-null state.

```cpp
#include <memory>
#include <iostream>

int main() {
    auto u = std::make_unique<int>(42);
    // get()
    int* raw = u.get();

    // release()
    int* released = u.release();
    std::cout << "Released: " << *released << std::endl;
    delete released;

    // reset()
    u.reset(new int(7));
    std::cout << "Reset to: " << *u << std::endl;

    // swap()
    auto v = std::make_unique<int>(9);
    u.swap(v);
    std::cout << "u=" << *u << ", v=" << *v << std::endl;

    // operators
    if (u) std::cout << "Value via *: " << *u << std::endl;
    return 0;
}
```

### `std::shared_ptr` Methods

- **`get()`**: returns raw pointer without affecting count.
- **`reset()`**: releases ownership; if last owner, deletes object.
- **`swap(other)`**: exchanges managed objects.
- **`use_count()`**: returns number of `shared_ptr` owners.
- **`unique()`**: returns true if `use_count()==1`.
- **`operator*()` / `operator->()`**: dereference.
- **`operator bool()`**: checks non-null.

```cpp
#include <memory>
#include <iostream>

int main() {
    auto s1 = std::make_shared<int>(100);
    auto s2 = s1;
    std::cout << "count=" << s1.use_count() << std::endl;

    // unique()
    std::cout << std::boolalpha << "unique? " << s1.unique() << std::endl;

    // swap()
    auto s3 = std::make_shared<int>(200);
    s1.swap(s3);
    std::cout << "s1=" << *s1 << ", s3=" << *s3 << std::endl;

    // reset()
    s2.reset();
    std::cout << "after reset, count=" << s1.use_count() << std::endl;
    return 0;
}
```

### `std::weak_ptr` Methods

- **`expired()`**: returns true if managed object has been destroyed.
- **`lock()`**: returns `shared_ptr` if object alive, else empty.
- **`reset()`**: clears the weak reference.
- **`use_count()`**: returns number of strong owners.
- **`owner_before(other)`**: compares control blocks.

```cpp
#include <memory>
#include <iostream>

int main() {
    auto sp = std::make_shared<int>(5);
    std::weak_ptr<int> wp = sp;

    // use_count()
    std::cout << "strong count=" << wp.use_count() << std::endl;

    // expired()
    std::cout << "expired? " << std::boolalpha << wp.expired() << std::endl;

    // reset()
    wp.reset();
    std::cout << "after reset, expired? " << wp.expired() << std::endl;
    return 0;
}
```

### `std::auto_ptr` Methods (Deprecated)

- **`get()`**: returns raw pointer.
- **`release()`**: transfers ownership to caller and nulls pointer.
- **`reset(ptr)`**: deletes current and takes ownership of `ptr`.

```cpp
#include <memory>
#include <iostream>

int main() {
    std::auto_ptr<int> a(new int(10));
    // get()
    int* r = a.get();
    std::cout << "get()= " << *r << std::endl;

    // release()
    int* rc = a.release();
    std::cout << "released= " << *rc << std::endl;
    delete rc;

    // reset()
    a.reset(new int(20));
    std::cout << "reset()= " << *a << std::endl;
    return 0;
}
```
