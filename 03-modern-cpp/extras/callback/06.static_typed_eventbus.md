# Static Typed EventBus in C with Topic-Based Filtering

A lightweight, **static** EventBus for C that lets you publish and subscribe to **named topics**, ensuring each layer only receives the events it cares about. No dynamic allocation—everything is built on fixed-size arrays—yet retains modularity and decoupling.

---

## Table of Contents

- [Static Typed EventBus in C with Topic-Based Filtering](#static-typed-eventbus-in-c-with-topic-based-filtering)
  - [Table of Contents](#table-of-contents)
  - [Introduction](#introduction)
  - [Define Topics](#define-topics)
  - [Update Callback API](#update-callback-api)
  - [Implement the Bus Core](#implement-the-bus-core)
  - [Layer Wiring](#layer-wiring)
    - [Bottom Layer](#bottom-layer)
    - [Middle Layer](#middle-layer)
    - [Top Layer](#top-layer)
  - [Putting It All Together](#putting-it-all-together)

---

## Introduction

In embedded or low‑level C applications, you often need a simple event system without heap usage. This guide demonstrates how to build a **static**, topic‑based EventBus in plain C:

- **Static storage**: all subscribers live in a fixed array.
- **Topic filtering**: each event is tagged, and only matching subscribers are invoked.
- **Layer decoupling**: Bottom, Middle, and Top layers communicate solely via the bus.

By the end, you’ll have a clear pattern:

```
BOTTOM → (RAW events) → MIDDLE → (PACKET events) → TOP
```

---

## Define Topics

We tag each event with a `topic_t` so subscribers can filter by interest.

```c
// include/event_bus.h (top)
typedef enum {
    TOPIC_RAW,      // raw bytes from bottom layer
    TOPIC_PACKET,   // decoded packets from middle layer
    TOPIC_CONTROL,  // custom control events
    TOPIC_MAX       // count of valid topics
} topic_t;
```

- **TOPIC_RAW**: used by Bottom to publish raw data.
- **TOPIC_PACKET**: used by Middle to publish decoded packets.
- **TOPIC_CONTROL**: reserved for future commands or errors.

---

## Update Callback API

Modify your subscriber callback signature and subscription function to include the topic tag:

```c
// include/event_bus.h
#ifndef EVENT_BUS_H
#define EVENT_BUS_H
#include <stddef.h>

#define MAX_SUBSCRIBERS 16

// Callback now receives which topic and a numeric payload
typedef void (*event_cb_t)(topic_t topic, int code);

// Each subscriber record holds its topic filter + cb function
ntypedef struct {
    topic_t    topic;
    event_cb_t cb;
} subscriber_t;

typedef struct {
    subscriber_t subs[MAX_SUBSCRIBERS];
    size_t       count;
} event_bus_t;

// Initializes internal counter to zero
void       event_bus_init(event_bus_t *bus);
// Registers cb for events on 'topic'
int        event_bus_subscribe(event_bus_t *bus, topic_t topic, event_cb_t cb);
// Publishes an event to all subscribers matching 'topic'
void       event_bus_publish(const event_bus_t *bus, topic_t topic, int code);

#endif // EVENT_BUS_H
```

**Explanation:**

- **event_cb_t** now takes `topic_t topic` so handlers know which topic triggered them (useful if one cb handles multiple topics).
- **event_bus_subscribe** takes the desired `topic` so only matching events reach that subscriber.

---

## Implement the Bus Core

In `src/event_bus.c`, filter subscribers by their registered topic:

```c
#include "event_bus.h"
#include <stdio.h>

void event_bus_init(event_bus_t *bus) {
    bus->count = 0;
}

int event_bus_subscribe(event_bus_t *bus, topic_t topic, event_cb_t cb) {
    if (bus->count >= MAX_SUBSCRIBERS) {
        return -1;  // no more slots
    }
    bus->subs[bus->count++] = (subscriber_t){ .topic = topic, .cb = cb };
    return 0;
}

void event_bus_publish(const event_bus_t *bus, topic_t topic, int code) {
    // Only invoke callbacks registered for this topic
    for (size_t i = 0; i < bus->count; ++i) {
        if (bus->subs[i].topic == topic) {
            bus->subs[i].cb(topic, code);
        }
    }
}
```

- **event_bus_init** clears the subscriber list.
- **event_bus_subscribe** adds a (topic, cb) pair.
- **event_bus_publish** loops subscribers and calls only those matching `topic`.

---

## Layer Wiring

Each layer now **only** touches the bus, never directly calling other layers’ functions.

### Bottom Layer

Publishes raw data on `TOPIC_RAW`:

```c
// src/bottom_layer.c
#include "bottom_layer.h"
#include "event_bus.h"
#include <stdio.h>

void bottom_do_work(event_bus_t *bus) {
    printf("[Bottom] reading raw bytes...\n");
    int raw_code = /* e.g. first byte or length */ 0x42;
    event_bus_publish(bus, TOPIC_RAW, raw_code);
}
```

### Middle Layer

Subscribed to `TOPIC_RAW`, decodes SLIP, then re-publishes on `TOPIC_PACKET`:

```c
// src/middle_layer.c
#include "middle_layer.h"
#include "event_bus.h"
#include <stdio.h>

static event_bus_t *mb_bus;

// Called when Bottom publishes TOPIC_RAW
static void middle_raw_cb(topic_t topic, int raw_code) {
    printf("[Middle] got raw 0x%X, decoding...\n", raw_code);
    int packet_code = /* SLIP decode logic */ raw_code ^ 0xFF;
    event_bus_publish(mb_bus, TOPIC_PACKET, packet_code);
}

void middle_init(event_bus_t *bus) {
    mb_bus = bus;
    event_bus_subscribe(bus, TOPIC_RAW, middle_raw_cb);
}
```

### Top Layer

Only subscribes to `TOPIC_PACKET`:

```c
// src/top_layer.c
#include "top_layer.h"
#include "event_bus.h"
#include <stdio.h>

static void top_packet_cb(topic_t topic, int packet_code) {
    printf("[Top] received packet code: %d\n", packet_code);
}

void top_init(event_bus_t *bus) {
    event_bus_subscribe(bus, TOPIC_PACKET, top_packet_cb);
}
```

---

## Putting It All Together

```c
// src/main.c
#include "event_bus.h"
#include "bottom_layer.h"
#include "middle_layer.h"
#include "top_layer.h"

int main(void) {
    event_bus_t bus;
    event_bus_init(&bus);

    middle_init(&bus);  // subscribe to RAW
    top_init(&bus);     // subscribe to PACKET

    bottom_do_work(&bus);  // publish RAW → middle → PACKET → top
    return 0;
}
```

**Build with:**

```bash
gcc -std=c11 -Iinclude src/event_bus.c src/bottom_layer.c \
    src/middle_layer.c src/top_layer.c src/main.c -o eventbus_app
./eventbus_app
```

Expected output:

```
[Middle] got raw 0x42, decoding...
[Top] received packet code: 213
```
