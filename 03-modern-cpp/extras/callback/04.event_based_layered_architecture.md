# Macro-Based EventBus Callback Registration (C)

This README explains how to use a **helper macro** in C to **assign** and **register** callbacks at the same time, hiding explicit `event_bus_register()` calls. The pattern supports a three-layer architecture:

1. **Top Layer** calls **Middle Layer** calls **Bottom Layer** (downward flow).
2. **Bottom Layer** raises events that invoke registered callbacks in Middle then Top (upward callbacks).

## Table of Contents

1. [Overview](#overview)
2. [Files & Code](#files--code)

   - [event_bus.h / event_bus.c](#event_bush--event_busc)
   - [middle_layer.h / middle_layer.c](#middle_layerh--middle_layerc)
   - [top_layer.h / top_layer.c](#top_layerh--top_layerc)
   - [main.c](#mainc)

3. [Registration Macro](#registration-macro)
4. [Flow Explanation](#flow-explanation)
5. [Compilation](#compilation)

## Overview

Instead of calling `event_bus_register(bus, handler)` explicitly for every callback, we define a small macro:

```c
#define REGISTER_CB(bus, cbs, member, handler) \
    do {                                       \
        (cbs)->member = handler;               \
        event_bus_register(bus, handler);      \
    } while(0)
```

When you write:

```c
REGISTER_CB(bus, cbs, on_event1, middle_on_event1);
```

you:

1. Assign `cbs->on_event1 = middle_on_event1;`
2. Call `event_bus_register(bus, middle_on_event1);`

This simplifies callback setup and keeps each layer’s **init** function concise.

## Files & Code

### event_bus.h / event_bus.c

```c
// event_bus.h
#ifndef EVENT_BUS_H
#define EVENT_BUS_H

#include <stdio.h>
#define MAX_SUBSCRIBERS 10

typedef void (*event_cb_t)(int code);
typedef struct {
    event_cb_t subscribers[MAX_SUBSCRIBERS];
    int        count;
} event_bus_t;

void event_bus_init(event_bus_t *bus);
int  event_bus_register(event_bus_t *bus, event_cb_t cb);
void event_bus_publish(event_bus_t *bus, int code);

#endif // EVENT_BUS_H
```

```c
// event_bus.c
#include "event_bus.h"

void event_bus_init(event_bus_t *bus) {
    bus->count = 0;
}

int event_bus_register(event_bus_t *bus, event_cb_t cb) {
    if (bus->count < MAX_SUBSCRIBERS) {
        bus->subscribers[bus->count++] = cb;
        return 0;
    }
    return -1;
}

void event_bus_publish(event_bus_t *bus, int code) {
    printf("[EventBus] published event %d\n", code);
    for (int i = 0; i < bus->count; ++i) {
        bus->subscribers[i](code);
    }
}
```

---

### middle_layer.h / middle_layer.c

```c
// middle_layer.h
#ifndef MIDDLE_LAYER_H
#define MIDDLE_LAYER_H

#include "event_bus.h"

typedef struct {
    event_cb_t on_event1;
    event_cb_t on_event2;
    event_cb_t on_event3;
} middle_callbacks_t;

// Macro hides register call
#define REGISTER_CB(bus, cbs, member, handler) \
    do {                                       \
        (cbs)->member = handler;               \
        event_bus_register(bus, handler);      \
    } while(0)

void middle_init(event_bus_t *bus, middle_callbacks_t *cbs);
void middle_do(event_bus_t *bus);

#endif // MIDDLE_LAYER_H
```

```c
// middle_layer.c
#include "middle_layer.h"
#include "bottom_layer.h"

static void middle_on_event1(int code) {
    printf("[Middle] callback#1 got %d\n", code);
}
static void middle_on_event2(int code) {
    printf("[Middle] callback#2 got %d\n", code);
}
static void middle_on_event3(int code) {
    printf("[Middle] callback#3 got %d\n", code);
}

void middle_init(event_bus_t *bus, middle_callbacks_t *cbs) {
    REGISTER_CB(bus, cbs, on_event1, middle_on_event1);
    REGISTER_CB(bus, cbs, on_event2, middle_on_event2);
    REGISTER_CB(bus, cbs, on_event3, middle_on_event3);
}

void middle_do(event_bus_t *bus) {
    printf("[Middle] calling Bottom\n");
    bottom_do_work();
    bottom_notify(bus, 42);
}
```

---

### top_layer.h / top_layer.c

```c
// top_layer.h
#ifndef TOP_LAYER_H
#define TOP_LAYER_H

#include "event_bus.h"
#include "middle_layer.h"

typedef struct {
    event_cb_t on_event1;
    event_cb_t on_event2;
    event_cb_t on_event3;
} top_callbacks_t;

#define REGISTER_CB(bus, cbs, member, handler) \
    do {                                       \
        (cbs)->member = handler;               \
        event_bus_register(bus, handler);      \
    } while(0)

void top_init(event_bus_t *bus, top_callbacks_t *cbs);
void top_do(event_bus_t *bus);

#endif // TOP_LAYER_H
```

```c
// top_layer.c
#include "top_layer.h"

static void top_on_event1(int code) {
    printf("[Top   ] callback#1 got %d\n", code);
}
static void top_on_event2(int code) {
    printf("[Top   ] callback#2 got %d\n", code);
}
static void top_on_event3(int code) {
    printf("[Top   ] callback#3 got %d\n", code);
}

void top_init(event_bus_t *bus, top_callbacks_t *cbs) {
    REGISTER_CB(bus, cbs, on_event1, top_on_event1);
    REGISTER_CB(bus, cbs, on_event2, top_on_event2);
    REGISTER_CB(bus, cbs, on_event3, top_on_event3);
}

void top_do(event_bus_t *bus) {
    printf("[Top   ] calling Middle\n");
    middle_do(bus);
}
```

---

### main.c

```c
#include <stdio.h>
#include "bottom_layer.h"
#include "middle_layer.h"
#include "top_layer.h"
#include "event_bus.h"

int main(void) {
    event_bus_t        bus;
    middle_callbacks_t m_cbs;
    top_callbacks_t    t_cbs;

    event_bus_init(&bus);
    middle_init(&bus, &m_cbs);
    top_init(&bus,    &t_cbs);

    printf("=== Begin Flow ===\n");
    top_do(&bus);
    printf("==== End Flow ====\n");

    return 0;
}
```

## Registration Macro

- **Assign + Register** in one step:

  ```c
  REGISTER_CB(bus, cbs, on_event1, middle_on_event1);
  ```

- Expands to:

  ```c
  cbs->on_event1 = middle_on_event1;
  event_bus_register(bus, middle_on_event1);
  ```

## Flow Explanation

1. **Downward**: `main()` → `top_do()` → `middle_do()` → `bottom_do_work()`
2. **Upward**: in `bottom_notify(code)`, EventBus invokes all callbacks registered by `REGISTER_CB`:

   - `middle_on_event1/2/3(code)`
   - `top_on_event1/2/3(code)`

## Compilation

```bash
gcc event_bus.c middle_layer.c top_layer.c bottom_layer.c main.c -o macro_app
./macro_app
```

This README documents the macro-based callback registration and dual-call design for a layered C application.
