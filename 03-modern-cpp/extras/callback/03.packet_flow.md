# Layered Packet‐Flow Callback Example

A minimal, header‐free C example that models a three‐layer packet processing pipeline:

1. **Bottom layer** receives raw SLIP‐encoded data (from hardware, ISR, driver callback, etc.) and notifies the Middle layer via registered callbacks.
2. **Middle layer** SLIP‐decodes each buffer, then notifies the Top layer via its own callbacks.
3. **Top layer** parses the decoded payload and performs application‐level handling.

All code resides in four .c files—no separate headers.

---

## Table of Contents

- [Layered Packet‐Flow Callback Example](#layered-packetflow-callback-example)
  - [Table of Contents](#table-of-contents)
  - [Architecture Overview](#architecture-overview)
  - [Data Model](#data-model)
  - [File: bottom\_layer.c](#file-bottom_layerc)
  - [File: middle\_layer.c](#file-middle_layerc)
  - [File: top\_layer.c](#file-top_layerc)
  - [File: main.c](#file-mainc)
  - [Build \& Run](#build--run)
  - [Expected Output](#expected-output)

---

## Architecture Overview

1. **Registration APIs**
   - **Bottom** exposes bottom_register_middle(PacketCB cb) so Middle can register one or more handlers.
   - **Middle** exposes middle_register_top(PacketCB cb) so Top can register its parser.
2. **Callback Flow**
   - **Downward**: main() → top_do() → (simulated) bottom_receive()
   - **Upward**:
     - bottom*receive() invokes \_all* Middle handlers.
     - Each middle*on_raw() SLIP‐decodes and invokes \_all* Top handlers.
3. **No polling**—each layer reacts immediately when its predecessor calls its callback.

---

## Data Model

c
typedef struct {
uint8_t \*data; // pointer into raw or decoded buffer
size_t len; // length of the buffer
} Packet;

typedef void (*PacketCB)(Packet *p);

---

## File: bottom_layer.c

c
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>

typedef struct { uint8_t *data; size_t len; } Packet;
typedef void (*PacketCB)(Packet \*);

#define MAX_MIDDLE_CBS 10

static PacketCB middle_cbs[MAX_MIDDLE_CBS];
static int middle_count = 0;

// Let Middle register its callback(s)
int bottom_register_middle(PacketCB cb) {
if (middle_count < MAX_MIDDLE_CBS) {
middle_cbs[middle_count++] = cb;
return 0;
}
return -1;
}

// Called by “hardware” or test code when raw SLIP packet arrives
void bottom_receive(uint8_t \*raw, size_t len) {
Packet pkt = { raw, len };
printf("[Bottom] received %zu bytes\n", len);
for (int i = 0; i < middle_count; i++) {
middle_cbs[i](&pkt);
}
}

---

## File: middle_layer.c

c
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>

typedef struct { uint8_t *data; size_t len; } Packet;
typedef void (*PacketCB)(Packet \*);

// Bottom‐layer API
int bottom_register_middle(PacketCB cb);
void bottom_receive(uint8_t \*raw, size_t len);

#define MAX_TOP_CBS 10

static PacketCB top_cbs[MAX_TOP_CBS];
static int top_count = 0;

// Let Top register its parser
int middle_register_top(PacketCB cb) {
if (top_count < MAX_TOP_CBS) {
top_cbs[top_count++] = cb;
return 0;
}
return -1;
}

// Simple SLIP‐decode: strip 0x7E framing bytes
static void slip_decode(uint8_t *in, size_t in_len,
uint8_t \*\*out, size_t *out_len) {
*out = malloc(in_len);
*out_len = 0;
for (size_t i = 0; i < in_len; i++) {
if (in[i] != 0x7E)
(*out)[(*out_len)++] = in[i];
}
}

// Called automatically by bottom_receive()
static void middle_on_raw(Packet \*raw) {
printf("[Middle] decoding %zu bytes\n", raw->len);

    uint8_t *dec_data;
    size_t   dec_len;
    slip_decode(raw->data, raw->len, &dec_data, &dec_len);

    Packet decoded = { dec_data, dec_len };
    for (int i = 0; i < top_count; i++) {
        top_cbs[i](&decoded);
    }
    free(dec_data);

}

// Must be invoked once at program startup
void middle_init(void) {
bottom_register_middle(middle_on_raw);
}

---

## File: top_layer.c

c
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>

typedef struct { uint8_t *data; size_t len; } Packet;
typedef void (*PacketCB)(Packet \*);

// Middle‐layer API
void middle_init(void);
int middle_register_top(PacketCB cb);
void bottom_receive(uint8_t \*raw, size_t len);

// Application‐level parser
static void top_on_decoded(Packet \*pkt) {
printf("[Top ] parsed %zu bytes:", pkt->len);
for (size_t i = 0; i < pkt->len; i++)
printf(" %02X", pkt->data[i]);
printf("\n");
}

// Initialize and register parser
void top_init(void) {
middle_init();
middle_register_top(top_on_decoded);
}

// Trigger a receive/test cycle
void top_do(void) {
// Simulated SLIP packet: 0x7E framing + payload bytes {0x01, 0x02}
uint8_t raw[] = { 0x7E, 0x01, 0x02, 0x7E };
bottom_receive(raw, sizeof(raw));
}

---

## File: main.c

c
#include <stdio.h>

// Top API
void top_init(void);
void top_do(void);

int main(void) {
top_init();

    printf("=== Packet Flow ===\n");
    top_do();
    printf("==== End ====\n");
    return 0;

}

---

## Build & Run

bash
gcc bottom_layer.c middle_layer.c top_layer.c main.c -o layered_app
./layered_app

---

## Expected Output

=== Packet Flow ===
[Bottom] received 4 bytes
[Middle] decoding 4 bytes
[Top ] parsed 2 bytes: 01 02
==== End ====

---

**Notes & Extensions**

- Replace slip_decode stub with your real SLIP decoder.
- Register multiple callbacks by calling bottom_register_middle() or middle_register_top() more than once.
- In a real system, bottom_receive() would be invoked from an ISR or driver callback.
- Adjust buffer management (stack vs. heap) to suit resource constraints.
