# Simple Smart-Pointers for `int`: `UniqueIntPtr` & `SharedIntPtr`

This guide shows two minimal, **non-template** smart-pointer classes specialized for `int*`.  
They illustrate core C++ principles—**RAII**, move semantics, and reference counting—without the complexity of templates.

> **RAII** (Resource Acquisition Is Initialization) means that resource management (allocation and deallocation) is tied to object lifetime. When a smart-pointer object is constructed, it acquires ownership of a pointer; when it is destroyed (goes out of scope), its destructor releases the resource automatically.

---

## Table of Contents

- [Simple Smart-Pointers for `int`: `UniqueIntPtr` \& `SharedIntPtr`](#simple-smart-pointers-for-int-uniqueintptr--sharedintptr)
  - [Table of Contents](#table-of-contents)
  - [Why RAII Matters](#why-raii-matters)
  - [1. `UniqueIntPtr`: Exclusive Ownership](#1-uniqueintptr-exclusive-ownership)
    - [Features](#features)
    - [`UniqueIntPtr.hpp`](#uniqueintptrhpp)
  - [2. `SharedIntPtr`: Shared Ownership](#2-sharedintptr-shared-ownership)
    - [Features](#features-1)
    - [`SharedIntPtr.hpp`](#sharedintptrhpp)
  - [3. Putting It All Together: Usage](#3-putting-it-all-together-usage)
  - [4. Key Takeaways](#4-key-takeaways)

---

## Why RAII Matters

- **Safety**: Automatic cleanup prevents memory leaks—even if exceptions are thrown.
- **Clarity**: Ownership semantics are encoded in types (`UniqueIntPtr` vs. `SharedIntPtr`).
- **Simplicity**: No need to remember `delete`; the destructor always runs when an object leaves scope.

---

## 1. `UniqueIntPtr`: Exclusive Ownership

`UniqueIntPtr` manages a single `int*`.  
Only one `UniqueIntPtr` may own that pointer at a time.

### Features

- **Move-only**: cannot be copied, only moved.
- **Destructor** automatically calls `delete ptr_;`.
- **Release** or **reset** to transfer or change ownership.

### `UniqueIntPtr.hpp`

```cpp
#ifndef UNIQUE_INT_PTR_HPP
#define UNIQUE_INT_PTR_HPP

class UniqueIntPtr {
public:
    // Acquire ownership of p
    explicit UniqueIntPtr(int* p = nullptr) noexcept
      : ptr_(p) {}

    // Destroy the owned int
    ~UniqueIntPtr() {
        delete ptr_;
    }

    // Move ctor: steal ownership
    UniqueIntPtr(UniqueIntPtr&& o) noexcept
      : ptr_(o.ptr_) {
        o.ptr_ = nullptr;
    }

    // Move-assignment: release old, steal new
    UniqueIntPtr& operator=(UniqueIntPtr&& o) noexcept {
        if (this != &o) {
            delete ptr_;
            ptr_ = o.ptr_;
            o.ptr_ = nullptr;
        }
        return *this;
    }

    // Disable copy
    UniqueIntPtr(const UniqueIntPtr&) = delete;
    UniqueIntPtr& operator=(const UniqueIntPtr&) = delete;

    // Observers
    int& operator*()  const noexcept { return *ptr_; }
    int* operator->() const noexcept { return ptr_; }
    int* get()        const noexcept { return ptr_; }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    // Release and return the raw pointer (no deletion)
    int* release() noexcept {
        int* p = ptr_;
        ptr_ = nullptr;
        return p;
    }

    // Delete the current int (if any) and take ownership of p
    void reset(int* p = nullptr) noexcept {
        delete ptr_;
        ptr_ = p;
    }

private:
    int* ptr_;
};

#endif // UNIQUE_INT_PTR_HPP
```

---

## 2. `SharedIntPtr`: Shared Ownership

`SharedIntPtr` manages a shared `int*` with a simple reference count.
Multiple `SharedIntPtr` instances can co-own the same pointer; it’s deleted when the last owner is destroyed.

### Features

- **Copyable**: copying increments the counter.
- **Moveable**: moves transfer ownership without altering count.
- **Destructor** decrements counter and deletes the `int` when it reaches zero.

### `SharedIntPtr.hpp`

```cpp
#ifndef SHARED_INT_PTR_HPP
#define SHARED_INT_PTR_HPP

#include <cstddef>   // for std::size_t
#include <utility>   // for std::swap

class SharedIntPtr {
public:
    // Acquire ownership: counter = 1 if p != nullptr
    explicit SharedIntPtr(int* p = nullptr)
      : ptr_(p), counter_(p ? new int(1) : nullptr)
    {}

    // Copy ctor: share ownership, bump counter
    SharedIntPtr(const SharedIntPtr& o)
      : ptr_(o.ptr_), counter_(o.counter_)
    {
        if (counter_) ++*counter_;
    }

    // Move ctor: steal pointers, leave o empty
    SharedIntPtr(SharedIntPtr&& o) noexcept
      : ptr_(o.ptr_), counter_(o.counter_)
    {
        o.ptr_ = nullptr;
        o.counter_ = nullptr;
    }

    // Copy-assignment: release old, then copy from o
    SharedIntPtr& operator=(const SharedIntPtr& o) {
        if (this != &o) {
            release();                // release existing resource
            ptr_ = o.ptr_;
            counter_ = o.counter_;
            if (counter_) ++*counter_;
        }
        return *this;
    }

    // Move-assignment: release old, steal from o
    SharedIntPtr& operator=(SharedIntPtr&& o) noexcept {
        if (this != &o) {
            release();
            ptr_ = o.ptr_;
            counter_ = o.counter_;
            o.ptr_ = nullptr;
            o.counter_ = nullptr;
        }
        return *this;
    }

    // Destructor: decrement counter, delete when zero
    ~SharedIntPtr() {
        release();
    }

    // Observers
    int& operator*()  const noexcept { return *ptr_; }
    int* operator->() const noexcept { return ptr_; }
    int* get()        const noexcept { return ptr_; }
    std::size_t use_count() const noexcept {
        return counter_ ? static_cast<std::size_t>(*counter_) : 0;
    }
    explicit operator bool() const noexcept { return ptr_ != nullptr; }

    // Replace managed pointer (resembles reset for unique_ptr)
    void reset(int* p = nullptr) {
        release();
        if (p) {
            ptr_ = p;
            counter_ = new int(1);
        }
    }

    // Swap two shared pointers (no ref count change)
    void swap(SharedIntPtr& o) noexcept {
        std::swap(ptr_, o.ptr_);
        std::swap(counter_, o.counter_);
    }

private:
    int* ptr_;
    int* counter_;

    // decrement counter and delete resources if needed
    void release() noexcept {
        if (counter_) {
            if (--*counter_ == 0) {
                delete ptr_;
                delete counter_;
            }
            ptr_ = nullptr;
            counter_ = nullptr;
        }
    }
};

#endif // SHARED_INT_PTR_HPP
```

---

## 3. Putting It All Together: Usage

```cpp
#include "UniqueIntPtr.hpp"
#include "SharedIntPtr.hpp"
#include <iostream>

int main() {
    // RAII in action: automatic cleanup on scope exit

    // UniqueIntPtr example
    UniqueIntPtr uw{ new int(42) };
    std::cout << "Unique value = " << *uw << "\n";

    // Transfer ownership
    UniqueIntPtr uw2 = std::move(uw);
    std::cout << "After move, uw empty? " << (!uw ? "yes" : "no") << "\n";

    // SharedIntPtr example
    SharedIntPtr sw1{ new int(100) };
    std::cout << "sw1 use_count = " << sw1.use_count() << "\n"; // 1

    SharedIntPtr sw2 = sw1;  // copy — use_count becomes 2
    std::cout << "After copy, sw1/sw2 use_count = "
              << sw1.use_count() << "/" << sw2.use_count() << "\n";

    sw1.reset(new int(7));   // old 100 freed, new count starts at 1
    std::cout << "After reset, sw1 uses " << *sw1
              << " (count=" << sw1.use_count() << ")\n";

    return 0;
}
```

---

## 4. Key Takeaways

- **RAII** ties resource lifetime (heap allocation) to object lifetime—no manual `delete` in user code.
- **UniqueIntPtr** enforces **exclusive** ownership and is **move-only**.
- **SharedIntPtr** supports **shared** ownership with a simple **reference counter**, deleting the `int` only when the last owner goes out of scope.
- These examples strip away template complexity to show the **mechanics** behind `std::unique_ptr<int>` and `std::shared_ptr<int>`.

```

```
