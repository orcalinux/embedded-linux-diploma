# Mastering Strings in C++

A comprehensive guide covering **C‑style strings** (from `<cstring>`) and the C++ **`std::string`** class, packed with real‑world examples and code snippets. Perfect for intermediate to advanced developers who want both breadth and depth.

---

## Table of Contents

- [Mastering Strings in C++](#mastering-strings-in-c)
  - [Table of Contents](#table-of-contents)
  - [Introduction](#introduction)
  - [C‑Style Strings (`<cstring>`)](#cstyle-strings-cstring)
    - [Null‑Terminated Strings](#nullterminated-strings)
    - [Common Functions](#common-functions)
      - [`strlen`](#strlen)
      - [`strcpy` / `strncpy`](#strcpy--strncpy)
      - [`strcat` / `strncat`](#strcat--strncat)
      - [`strcmp` / `strncmp`](#strcmp--strncmp)
      - [`strchr` / `strrchr`](#strchr--strrchr)
      - [`strstr`](#strstr)
      - [`memset` / `memcpy`](#memset--memcpy)
    - [Examples](#examples)
  - [`std::string` Basics](#stdstring-basics)
    - [Including \& Namespaces](#including--namespaces)
    - [String Literals (`""s`)](#string-literals-s)
    - [Construction](#construction)
    - [Assignment \& Concatenation](#assignment--concatenation)
    - [Accessing Characters](#accessing-characters)
  - [Capacity \& Size](#capacity--size)
  - [Modifiers](#modifiers)
    - [`append()` / `push_back()`](#append--push_back)
    - [`insert()`](#insert)
    - [`erase()`](#erase)
    - [`replace()`](#replace)
    - [`clear()` / `swap()`](#clear--swap)
  - [Searching \& Substrings](#searching--substrings)
    - [`find()` / `rfind()`](#find--rfind)
    - [`find_first_of()` / `find_last_of()`](#find_first_of--find_last_of)
    - [`substr()`](#substr)
    - [`compare()`](#compare)
  - [Iterators](#iterators)
  - [Conversion \& Interop](#conversion--interop)
  - [Best Practices \& Pitfalls](#best-practices--pitfalls)
  - [Further Reading](#further-reading)

---

## Introduction

Strings are fundamental in every programming language. In C++, you can choose between low‑level **C‑style strings** (arrays of `char` ending with `'\0'`) or the safer, more expressive **`std::string`** class. This guide breaks down both worlds, starting with `<cstring>` functions before diving deep into `std::string`.

---

## C‑Style Strings (`<cstring>`)

### Null‑Terminated Strings

A C‑style string is simply a sequence of characters terminated by a null byte (`'\0'`):

```cpp
char hello[] = "Hello, world!";  // includes '\0' at the end
char buf[16];                     // uninitialized buffer
```

The terminating `'\0'` lets library functions know where the string ends.

### Common Functions

#### `strlen`

Returns the length (excluding `'\0'`).

```cpp
#include <cstring>
size_t len = std::strlen("Hello");  // len == 5
```

#### `strcpy` / `strncpy`

Copy one string to another. **Beware** of buffer overflows with `strcpy`.

```cpp
char src[] = "Source";
char dst[16];
std::strcpy(dst, src);             // dst now contains "Source"

char smallDst[4];
std::strncpy(smallDst, src, 3);    // copies "Sou"
smallDst[3] = '\0';                // ensure null-termination
```

#### `strcat` / `strncat`

Concatenate strings.

```cpp
char s1[32] = "Hello, ";
char s2[]   = "C-Style!";
std::strcat(s1, s2);               // s1 == "Hello, C-Style!"
```

#### `strcmp` / `strncmp`

Compare two strings lexicographically.

```cpp
int r1 = std::strcmp("abc", "abd");      // r1 < 0
int r2 = std::strncmp("abcd", "abce", 3);// compares only "abc"
```

#### `strchr` / `strrchr`

Find a character in a string.

```cpp
const char* p = std::strchr("banana", 'n');   // points to first 'n'
const char* q = std::strrchr("banana", 'n');  // points to last 'n'
```

#### `strstr`

Find a substring.

```cpp
const char* sub = std::strstr("hello world", "world");  // points to "world"
```

#### `memset` / `memcpy`

Operate on raw memory (not string‑specific).

```cpp
char buffer[10];
std::memset(buffer, '*', 9);  // fill with '*' (no '\0')
buffer[9] = '\0';

char other[10];
std::memcpy(other, buffer, 10); // raw copy of 10 bytes
```

### Examples

```cpp
#include <iostream>
#include <cstring>

int main() {
    char a[20] = "C-";
    std::strcat(a, "Strings");
    std::cout << a << " has length " << std::strlen(a) << "\n";

    if (std::strcmp(a, "C-Strings") == 0) {
        std::cout << "They match!\n";
    }

    char msg[] = "Find the needle in this haystack";
    const char* needle = std::strstr(msg, "needle");
    if (needle) {
        std::cout << "Found at position: " << (needle - msg) << "\n";
    }
    return 0;
}
```

---

## `std::string` Basics

### Including & Namespaces

```cpp
#include <string>
#include <iostream>

using std::string;
using std::cout;
using std::endl;
```

### String Literals (`""s`)

Since **C++14** you can write a literal `std::string` directly by suffixing `s`:

```cpp
#include <string>
using namespace std::string_literals;  // brings in operator""s

auto s1 = "Hello, world!"s;            // std::string initialized from literal
auto s2 = "Foo\nBar"s;                 // supports escape sequences
```

**Why use it?**

- **Convenience:** no explicit constructor call
- **Clarity:** shows intent at the call site
- **Performance:** lets the compiler optimize allocation in some cases

You can also mix `constexpr std::string_view` literals (from `<string_view>`) by using the `""sv` suffix:

```cpp
#include <string_view>
using namespace std::string_view_literals;

constexpr auto sv = "read-only view"sv;  // std::string_view
```

### Construction

```cpp
string s1;                     // empty string
string s2("Hello");            // from C‑string
string s3(s2);                 // copy
string s4(5, '*');             // "*****"
string s5{s2, 1, 3};           // substring of s2: "ell"
```

### Assignment & Concatenation

```cpp
s1 = "Foo";
s1 += "Bar";                   // "FooBar"
string s6 = s2 + ", " + s1;    // "Hello, FooBar"
```

### Accessing Characters

```cpp
char c1 = s6[0];               // no bounds checking
char c2 = s6.at(1);            // throws std::out_of_range if invalid
```

---

## Capacity & Size

```cpp
string str = "Hello";
cout << str.size() << endl;      // 5
cout << str.length() << endl;    // same as size()
cout << str.capacity() << endl;  // implementation‑defined

str.reserve(100);                // ensure room for 100 chars
str.shrink_to_fit();             // reduce capacity to size
```

---

## Modifiers

### `append()` / `push_back()`

```cpp
string t = "Data";
t.append(" Structures");        // "Data Structures"
t.push_back('!');               // "Data Structures!"
```

### `insert()`

```cpp
string u = "C++ Rules!";
u.insert(3, " is awesome");     // "C++ is awesome Rules!"
u.insert(u.begin(), '*');       // "*C++ is awesome Rules!"
```

### `erase()`

```cpp
string v = "Erase this part";
v.erase(6, 5);                  // removes 5 chars at pos 6 -> "Erase  part"
v.erase(std::remove(v.begin(), v.end(), ' '), v.end()); // remove spaces
```

### `replace()`

```cpp
string w = "I like C++";
w.replace(7, 3, "modern C++");  // "I like modern C++"
```

### `clear()` / `swap()`

```cpp
string x = "Temporary";
x.clear();                      // now empty
string a = "A", b = "B";
a.swap(b);                      // a=="B", b=="A"
```

---

## Searching & Substrings

### `find()` / `rfind()`

```cpp
string text = "Find the first and last occurrence of 'the'";
size_t p1 = text.find("the");             // first "the"
size_t p2 = text.rfind("the");            // last  "the"
```

### `find_first_of()` / `find_last_of()`

```cpp
string letters = "abcdefg";
size_t p3 = letters.find_first_of("xzg"); // finds 'g' at pos 6
size_t p4 = letters.find_last_of("abc");  // finds 'c' at pos 2
```

### `substr()`

```cpp
string sub = text.substr(5, 9);           // 9 chars starting at pos 5
```

### `compare()`

```cpp
int cmp = text.compare(5, 3, "the");      // compares substring "the" to "the"
if (cmp == 0) cout << "Match!\n";
```

---

## Iterators

```cpp
string hello = "Iterate";
for (auto it = hello.begin(); it != hello.end(); ++it) {
    cout << *it << ' ';
}
cout << endl;

// Range‑based
for (char ch : hello) {
    cout << ch;
}
```

---

## Conversion & Interop

```cpp
string num = "12345";
int    value = std::stoi(num);               // 12345
long   lv    = std::stol("67890");
string back  = std::to_string(3.1415);       // "3.141500"

// C‑string access
const char* cs = hello.c_str();
```

---

## Best Practices & Pitfalls

- **Prefer** `std::string` over C‑style for safety and convenience.
- Always ensure **null‑termination** when using raw buffers.
- Use **`.at()`** for bounds‑checked access in debugging.
- Beware of `std::string::data()` in pre‑C++17: not guaranteed null‑terminated.
- Reserve capacity when building large strings in loops to avoid reallocations.

---

## Further Reading

- C++ Reference: [cppreference.com/string](https://en.cppreference.com/w/cpp/string/basic_string)
- **“The C++ Programming Language”** by Bjarne Stroustrup
- **“Effective STL”** by Scott Meyers (Chapter on strings)
- Articles on performance implications of small string optimization (SSO)
