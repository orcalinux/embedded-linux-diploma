# String: Implementing a C++ String Class from Scratch

A hands‑on guide to building a minimal `String` class in C++, illustrating core concepts like dynamic allocation, RAII, copy/move semantics, exception safety, iterator support, and common string operations.

---

## Table of Contents

- [String: Implementing a C++ String Class from Scratch](#string-implementing-a-c-string-class-from-scratch)
  - [Table of Contents](#table-of-contents)
  - [1. Introduction](#1-introduction)
  - [2. Design Goals](#2-design-goals)
  - [3. Prerequisites](#3-prerequisites)
  - [4. Class Interface Overview](#4-class-interface-overview)
  - [5. Member Variables \& Invariants](#5-member-variables--invariants)
  - [6. Memory Management Strategy](#6-memory-management-strategy)
  - [7. Constructors \& Destructor](#7-constructors--destructor)
  - [8. Copy \& Move Semantics](#8-copy--move-semantics)
  - [9. Element Access](#9-element-access)
  - [10. Capacity Management](#10-capacity-management)
  - [11. Modifiers](#11-modifiers)
  - [12. String Operations](#12-string-operations)
  - [13. Comparison Operators](#13-comparison-operators)
  - [14. I/O Support](#14-io-support)
  - [15. Iterator Interface](#15-iterator-interface)
  - [16. Exception Safety Guarantees](#16-exception-safety-guarantees)
  - [17. Performance \& Complexity Analysis](#17-performance--complexity-analysis)
  - [18. Unit Tests Example](#18-unit-tests-example)
  - [19. Appendix: Small String Optimization (SSO)](#19-appendix-small-string-optimization-sso)
  - [20. Header \& Source Files](#20-header--source-files)
    - [String.hpp](#stringhpp)
    - [String.cpp](#stringcpp)
  - [20. Extensions \& Next Steps](#20-extensions--next-steps)

---

## 1. Introduction

While C++ provides `std::string`, implementing your own `String` class helps you internalize:

- Dynamic memory allocation patterns
- RAII (Resource Acquisition Is Initialization) principles
- Copy vs. move semantics and ownership transfer
- Amortized growth strategies and performance
- Exception safety and strong guarantees
- Iterator interfaces consistent with STL

This guide walks through a minimal but robust implementation, emphasizing clarity and real‑world applicability.

## 2. Design Goals

- **Minimal**: Core features only, no templates or allocators
- **Safe**: Automatic memory management, bounds‑checked APIs
- **Efficient**: Amortized constant‑time `push_back` and `append`
- **Exception-Safe**: Provides basic or strong guarantees where applicable
- **Iterable**: Support `begin()`, `end()` for range‑based loops
- **Testable**: Include unit‑testable components

## 3. Prerequisites

- C++11 or newer compiler
- Familiarity with pointers, `new`/`delete[]`, and `<cstring>`
- Basic understanding of STL iterator patterns

## 4. Class Interface Overview

```cpp
class String {
public:
    // -- Construction & Destruction --
    String() noexcept;                        // empty string
    explicit String(const char* s);           // from C‑string
    String(const String& other);              // copy
    String(String&& other) noexcept;          // move
    ~String();                                // destructor

    // -- Assignment --
    String& operator=(const String& other);
    String& operator=(String&& other) noexcept;

    // -- Concatenation --
    String& operator+=(const String& other);
    friend String operator+(String lhs, const String& rhs);

    // -- Element Access --
    char&       operator[](size_t idx) noexcept;
    const char& operator[](size_t idx) const noexcept;
    char&       at(size_t idx);
    const char& at(size_t idx) const;

    // -- Capacity --
    size_t size()     const noexcept;
    size_t capacity() const noexcept;
    bool   empty()    const noexcept;
    void   reserve(size_t newCap);
    void   shrink_to_fit();

    // -- Modifiers --
    void   clear() noexcept;
    void   push_back(char c);
    void   pop_back();
    String& append(const char* s);
    String& insert(size_t pos, const char* s);
    String& erase(size_t pos, size_t len);

    // -- Operations --
    String  substr(size_t pos, size_t len) const;
    int     compare(const String& other) const noexcept;
    size_t  find(const char* s, size_t pos = 0) const noexcept;

    // -- Iterators --
    using iterator = char*;
    using const_iterator = const char*;
    iterator       begin() noexcept;
    iterator       end() noexcept;
    const_iterator begin() const noexcept;
    const_iterator end() const noexcept;

    // -- C‑string interop --
    const char* c_str() const noexcept;

    // -- Constants --
    static constexpr size_t npos = static_cast<size_t>(-1);

private:
    char*  data_ = nullptr;
    size_t size_ = 0;
    size_t capacity_ = 0;

    static constexpr size_t kGrowthFactor    = 2;
    static constexpr size_t kInitialCapacity = 15;

    void ensure_capacity(size_t minCap);
    void allocate_and_copy(const char* src, size_t len);
};
```

> **Note:** All pointers point to a buffer of `capacity_ + 1` bytes, and `data_[size_] == '\0'`.

## 5. Member Variables & Invariants

- `data_` points to a heap buffer of size `capacity_ + 1`.
- `data_[size_] == '\0'` always.
- **Invariant:** `0 <= size_ <= capacity_`.

## 6. Memory Management Strategy

- **Initial capacity:** `kInitialCapacity` (15) to optimize small allocations.
- **Growth:** On overflow, new capacity = `max(capacity_*kGrowthFactor, minCap)`.
- Always null‑terminate after modifications.

## 7. Constructors & Destructor

```cpp
String::String() noexcept
  : data_(new char[kInitialCapacity + 1]),
    size_(0),
    capacity_(kInitialCapacity) {
    data_[0] = '\0';
}

String::String(const char* s)
  : size_(std::strlen(s)),
    capacity_(std::max(size_, kInitialCapacity)),
    data_(new char[capacity_ + 1]) {
    std::memcpy(data_, s, size_ + 1);
}

String::~String() {
    delete[] data_;
}
```

**Usage example:**

```cpp
String empty;
String greeting("Hello, World!");
```

## 8. Copy & Move Semantics

```cpp
// Copy ctor
String::String(const String& other)
  : size_(other.size_),
    capacity_(other.capacity_),
    data_(new char[other.capacity_ + 1]) {
    std::memcpy(data_, other.data_, size_ + 1);
}

// Copy assignment
String& String::operator=(const String& other) {
    if (this != &other) {
        allocate_and_copy(other.data_, other.size_);
    }
    return *this;
}

// Move ctor
String::String(String&& other) noexcept
  : data_(other.data_),
    size_(other.size_),
    capacity_(other.capacity_) {
    other.data_    = new char[1];
    other.data_[0] = '\0';
    other.size_    = other.capacity_ = 0;
}

// Move assignment
String& String::operator=(String&& other) noexcept {
    if (this != &other) {
        delete[] data_;
        data_     = other.data_;
        size_     = other.size_;
        capacity_ = other.capacity_;
        other.data_    = new char[1];
        other.data_[0] = '\0';
        other.size_    = other.capacity_ = 0;
    }
    return *this;
}
```

> **Helper:** `allocate_and_copy` centralizes buffer allocation and copy logic.

```cpp
void String::allocate_and_copy(const char* src, size_t len) {
    char* newData = new char[len + 1];
    std::memcpy(newData, src, len);
    newData[len] = '\0';

    delete[] data_;
    data_     = newData;
    size_     = len;
    capacity_ = len;
}
```

## 9. Element Access

```cpp
char& String::operator[](size_t idx) noexcept {
    return data_[idx]; // no checking
}

char& String::at(size_t idx) {
    if (idx >= size_) throw std::out_of_range("Index out of range");
    return data_[idx];
}
```

**Example:**

```cpp
String s("Test");
s[1] = 'a'; // now "Ta…"
try {
    char c = s.at(10); // throws
} catch (std::out_of_range& e) {
    std::cerr << e.what();
}
```

## 10. Capacity Management

```cpp
void String::reserve(size_t newCap) {
    if (newCap <= capacity_) return;
    char* newData = new char[newCap + 1];
    std::memcpy(newData, data_, size_ + 1);
    delete[] data_;
    data_     = newData;
    capacity_ = newCap;
}

void String::shrink_to_fit() {
    if (capacity_ == size_) return;
    reserve(size_);
}

void String::ensure_capacity(size_t minCap) {
    if (capacity_ >= minCap) return;
    size_t newCap = std::max(minCap, capacity_ * kGrowthFactor);
    reserve(newCap);
}
```

**Example Growth:**

```cpp
String s;
for (int i = 0; i < 20; ++i) s.push_back('x');
std::cout << "size=" << s.size() << ", cap=" << s.capacity();
```

## 11. Modifiers

```cpp
void String::push_back(char c) {
    ensure_capacity(size_ + 1);
    data_[size_++] = c;
    data_[size_]   = '\0';
}

void String::pop_back() {
    if (size_) data_[--size_] = '\0';
}

String& String::append(const char* s) {
    size_t len = std::strlen(s);
    ensure_capacity(size_ + len);
    std::memcpy(data_ + size_, s, len + 1);
    size_ += len;
    return *this;
}
```

**Example:**

```cpp
String s("Hi");
s.append(", there"); // "Hi, there"
s.pop_back();       // removes 'e'
```

## 12. String Operations

```cpp
String String::substr(size_t pos, size_t len) const {
    if (pos > size_) throw std::out_of_range("substr pos > size");
    len = std::min(len, size_ - pos);
    String result;
    result.allocate_and_copy(data_ + pos, len);
    return result;
}

int String::compare(const String& other) const noexcept {
    return std::strcmp(data_, other.data_);
}

size_t String::find(const char* s, size_t pos) const noexcept {
    if (pos > size_) return npos;
    const char* p = std::strstr(data_ + pos, s);
    return p ? static_cast<size_t>(p - data_) : npos;
}
```

## 13. Comparison Operators

```cpp
bool operator==(const String& a, const String& b) { return a.compare(b) == 0; }
bool operator!=(const String& a, const String& b) { return !(a == b); }
bool operator<(const String& a, const String& b)  { return a.compare(b) <  0; }
bool operator<=(const String& a, const String& b) { return a.compare(b) <= 0; }
bool operator>(const String& a, const String& b)  { return a.compare(b) >  0; }
bool operator>=(const String& a, const String& b) { return a.compare(b) >= 0; }
```

## 14. I/O Support

```cpp
std::ostream& operator<<(std::ostream& os, const String& s) {
    return os << s.c_str();
}

std::istream& operator>>(std::istream& is, String& s) {
    char buf[1024];
    is >> buf;
    s = String(buf);
    return is;
}
```

## 15. Iterator Interface

Enable range‑based `for` loops:

```cpp
String s("abc");
for (char& c : s) {
    std::cout << c << " ";
}
// prints: a b c
```

## 16. Exception Safety Guarantees

- **Basic guarantee** in copy assignment: object remains valid on exceptions.
- **Strong guarantee** in `reserve`/`append`: operations either complete fully or roll back.

## 17. Performance & Complexity Analysis

| Operation   | Average Complexity | Amortized Complexity |
| ----------- | ------------------ | -------------------- |
| `push_back` | O(1) amortized     | O(1) amortized       |
| `append`    | O(n)               | O(n)                 |
| `reserve`   | O(n)               | O(n)                 |
| `substr`    | O(len)             | O(len)               |

## 18. Unit Tests Example

Using a simple assertion framework:

```cpp
void test_push_back() {
    String s;
    s.push_back('x');
    assert(s.size() == 1);
    assert(s[0] == 'x');
}

void test_concatenation() {
    String a("Hello, ");
    String b("World!");
    String c = a + b;
    assert(c == String("Hello, World!"));
    a += b;
    assert(a == c);
}

int main() {
    test_push_back();
    test_concatenation();
    // ... other tests
    std::cout << "All tests passed!\n";
}
```

## 19. Appendix: Small String Optimization (SSO)

Store short strings inline to avoid heap allocations:

```cpp
static constexpr size_t SSO_SIZE = 15;
union {
    char inline_buf[SSO_SIZE + 1];
    char* heap_buf;
} storage_;
bool using_sso_;
```

## 20. Header & Source Files

Below is the complete `.hpp`/`.cpp` split for our `String` class. Save the first snippet as `String.hpp` and the second as `String.cpp` in your project.

### String.hpp

```cpp
// String.hpp
#pragma once

#include <cstddef>
#include <cstring>
#include <algorithm>
#include <stdexcept>

class String {
public:
    // -- Construction & Destruction --
    String() noexcept;
    explicit String(const char* s);
    String(const String& other);
    String(String&& other) noexcept;
    ~String();

    // -- Assignment --
    String& operator=(const String& other);
    String& operator=(String&& other) noexcept;

    // -- Concatenation --
    String& operator+=(const String& other);
    friend String operator+(String lhs, const String& rhs);

    // -- Element Access --
    char& operator[](size_t idx) noexcept;
    const char& operator[](size_t idx) const noexcept;
    char& at(size_t idx);
    const char& at(size_t idx) const;

    // -- Capacity --
    size_t size() const noexcept;
    size_t capacity() const noexcept;
    bool empty() const noexcept;
    void reserve(size_t newCap);
    void shrink_to_fit();

    // -- Modifiers --
    void clear() noexcept;
    void push_back(char c);
    void pop_back();
    String& append(const char* s);
    String& insert(size_t pos, const char* s);
    String& erase(size_t pos, size_t len);

    // -- Operations --
    String substr(size_t pos, size_t len) const;
    int compare(const String& other) const noexcept;
    size_t find(const char* s, size_t pos = 0) const noexcept;

    // -- Iterators --
    using iterator = char*;
    using const_iterator = const char*;
    iterator       begin() noexcept;
    iterator       end() noexcept;
    const_iterator begin() const noexcept;
    const_iterator end() const noexcept;

    // -- C-string Interop --
    const char* c_str() const noexcept;

    // -- Constants --
    static constexpr size_t npos = static_cast<size_t>(-1);

private:
    char*  data_ = nullptr;
    size_t size_ = 0;
    size_t capacity_ = 0;

    static constexpr size_t kGrowthFactor    = 2;
    static constexpr size_t kInitialCapacity = 15;

    void ensure_capacity(size_t minCap);
    void allocate_and_copy(const char* src, size_t len);
};
```

### String.cpp

```cpp
// String.cpp
#include "String.hpp"
#include <cstring>
#include <algorithm>
#include <ostream>
#include <istream>

// -- Constructors & Destructor --
String::String() noexcept
    : data_(new char[kInitialCapacity + 1]),
      size_(0),
      capacity_(kInitialCapacity) {
    data_[0] = '\0';
}

String::String(const char* s)
    : size_(std::strlen(s)),
      capacity_(std::max(size_, kInitialCapacity)),
      data_(new char[capacity_ + 1]) {
    std::memcpy(data_, s, size_ + 1);
}

String::String(const String& other)
    : size_(other.size_),
      capacity_(other.capacity_),
      data_(new char[other.capacity_ + 1]) {
    std::memcpy(data_, other.data_, size_ + 1);
}

String::String(String&& other) noexcept
    : data_(other.data_),
      size_(other.size_),
      capacity_(other.capacity_) {
    other.data_    = new char[1];
    other.data_[0] = '\0';
    other.size_    = other.capacity_ = 0;
}

String::~String() {
    delete[] data_;
}

// -- Assignment --
String& String::operator=(const String& other) {
    if (this != &other) {
        allocate_and_copy(other.data_, other.size_);
    }
    return *this;
}

String& String::operator=(String&& other) noexcept {
    if (this != &other) {
        delete[] data_;
        data_     = other.data_;
        size_     = other.size_;
        capacity_ = other.capacity_;
        other.data_    = new char[1];
        other.data_[0] = '\0';
        other.size_    = other.capacity_ = 0;
    }
    return *this;
}

// -- Concatenation --
String& String::operator+=(const String& other) {
    append(other.data_);
    return *this;
}

String operator+(String lhs, const String& rhs) {
    lhs += rhs;
    return lhs;
}

// -- Element Access --
char& String::operator[](size_t idx) noexcept { return data_[idx]; }
const char& String::operator[](size_t idx) const noexcept { return data_[idx]; }
char& String::at(size_t idx) {
    if (idx >= size_) throw std::out_of_range("Index out of range");
    return data_[idx];
}
const char& String::at(size_t idx) const {
    if (idx >= size_) throw std::out_of_range("Index out of range");
    return data_[idx];
}

// -- Capacity --
size_t String::size() const noexcept     { return size_; }
size_t String::capacity() const noexcept { return capacity_; }
bool   String::empty() const noexcept    { return size_ == 0; }

void String::reserve(size_t newCap) {
    if (newCap <= capacity_) return;
    char* newData = new char[newCap + 1];
    std::memcpy(newData, data_, size_ + 1);
    delete[] data_;
    data_     = newData;
    capacity_ = newCap;
}

void String::shrink_to_fit() {
    if (capacity_ == size_) return;
    reserve(size_);
}

void String::ensure_capacity(size_t minCap) {
    if (capacity_ >= minCap) return;
    size_t newCap = std::max(minCap, capacity_ * kGrowthFactor);
    reserve(newCap);
}

// -- Modifiers --
void String::clear() noexcept { size_ = 0; data_[0] = '\0'; }
void String::push_back(char c) {
    ensure_capacity(size_ + 1);
    data_[size_++] = c;
    data_[size_]   = '\0';
}
void String::pop_back() {
    if (size_) data_[--size_] = '\0';
}
String& String::append(const char* s) {
    size_t len = std::strlen(s);
    ensure_capacity(size_ + len);
    std::memcpy(data_ + size_, s, len + 1);
    size_ += len;
    return *this;
}
String& String::insert(size_t pos, const char* s) {
    if (pos > size_) throw std::out_of_range("Insert position out of range");
    size_t len = std::strlen(s);
    ensure_capacity(size_ + len);
    std::memmove(data_ + pos + len, data_ + pos, size_ - pos + 1);
    std::memcpy(data_ + pos, s, len);
    size_ += len;
    return *this;
}
String& String::erase(size_t pos, size_t len) {
    if (pos > size_) throw std::out_of_range("Erase position out of range");
    len = std::min(len, size_ - pos);
    std::memmove(data_ + pos, data_ + pos + len, size_ - pos - len + 1);
    size_ -= len;
    return *this;
}

// -- Operations --
String String::substr(size_t pos, size_t len) const {
    if (pos > size_) throw std::out_of_range("substr position out of range");
    len = std::min(len, size_ - pos);
    String result;
    result.allocate_and_copy(data_ + pos, len);
    return result;
}
int String::compare(const String& other) const noexcept {
    return std::strcmp(data_, other.data_);
}
size_t String::find(const char* s, size_t pos) const noexcept {
    if (pos > size_) return npos;
    const char* p = std::strstr(data_ + pos, s);
    return p ? static_cast<size_t>(p - data_) : npos;
}

// -- Iterators --
String::iterator String::begin() noexcept       { return data_; }
String::iterator String::end() noexcept         { return data_ + size_; }
String::const_iterator String::begin() const noexcept { return data_; }
String::const_iterator String::end() const noexcept   { return data_ + size_; }

// -- C-string Interop --
const char* String::c_str() const noexcept { return data_; }

// -- Helpers --
void String::allocate_and_copy(const char* src, size_t len) {
    char* newData = new char[len + 1];
    std::memcpy(newData, src, len);
    newData[len] = '\0';
    delete[] data_;
    data_     = newData;
    size_     = len;
    capacity_ = len;
}

// -- Non-member Comparison & I/O --
bool operator==(const String& a, const String& b) { return a.compare(b) == 0; }
bool operator!=(const String& a, const String& b) { return !(a == b); }
bool operator<(const String& a, const String& b)  { return a.compare(b) < 0; }
bool operator<=(const String& a, const String& b) { return a.compare(b) <= 0; }
bool operator>(const String& a, const String& b)  { return a.compare(b) > 0; }
bool operator>=(const String& a, const String& b) { return a.compare(b) >= 0; }

std::ostream& operator<<(std::ostream& os, const String& s) { return os << s.c_str(); }
std::istream& operator>>(std::istream& is, String& s) {
    char buf[1024];
    is >> buf;
    s = String(buf);
    return is;
}
```

## 20. Extensions & Next Steps

- Allocator support via templates
- UTF‑8/Unicode‑aware operations
- Integration with `std::string_view`
- Overloads for `operator+`/`+=` with C‑strings
- Thread‑safety considerations
- Benchmark comparisons against `std::string`
